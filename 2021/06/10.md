模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。

### 一、CommonJS

Node.js是commonJS规范的主要实践者，他有四个重要的环境变量未模块化的实现提供支持：`module`、`exports`、`require`、`global`。实际使用时，用`module.exports`定义当前模块对外输出的接口，（不推荐直接用exports），用`require`加载模块。
```
```
#### 特点：
- 所有代码都运行在模块作用域，不会污染全局作用域；
- 模块是同步加载的，即只有加载完成，才能执行后面的操作；
- 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存；
- CommonJS输出是值的拷贝(即，require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值)。

commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是适用异步加载。

### 二、AMD和require.js

AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。实现方式有`require`；
依赖前置


### 五、ES6模块与CommonJS模块的差异

1、CommonJS输出的是一个值的拷贝，ES6输出的是一个值的引用

- CommonJS输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
- ES6模块的运行机制与CommonJS不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。原始值变了，import加载的值也会跟着变，因此，ES6模块是动态引用并且不会缓存值，模块里面的变量绑定桤所在的模块。

2、CommonJS在模块时在运行时加载，ES6是在编译时输出接口
- 运行时加载：CommonJS模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上读取读取方法，这种加载称为"运行时加载"
- 编译时加载：ES6模块不是对象，而是通过expory命令显式输出的代码，import时采用静态命令的形式。即在import时可以制定加载输出值，而不是加载整个模块，这种加载称为编译时加载。
- 



如果想在浏览器中适用CommonJS模块，就需要与其非原生的模块语法之间构筑“桥梁”。模块级代码与浏览器运行时之间也需要某种“屏障”，因为如果没有封装的CommonJS代码在浏览器中执行会创建全局变量。这显然与模块的初衷相悖。

常见的解决方案是提前把模块文件打包好，把全局属性转换为原生javascript结构，将模块代码封装在函数闭包中，最终只提供一个文件。为了以正确的顺序打包依赖，需要事先生成全面的依赖图。


script type=“module”标签会立即下载模块文件，单执行回延迟到文档解析完成
