![](https://camo.githubusercontent.com/dfeee62864c5cb924bdbd6a5a9ac4afd56ebd9c315a6e3348c89206377e53009/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f31302f313637393862386462353463616133313f773d36323426683d32383926663d706e6726733d3431303537)
### 浏览器的渲染过程
1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树（Render Tree）
3. Layout（回流）：根据生成的渲染树，进行回流（Layout），得到节点的几何信息（位置，大小）
4. Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素。
5. Display：将像素发给GPU，展示在页面上。

4\5 我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。

由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。

### 何时会发生回流
- Dom元素发生添加或删除
- 位置发生变化
- 尺寸发生变化
- 内容发生变化
- 窗口尺寸变化（回流是根据视口的大小计算元素的位置和大小的）

**回流一定会触发重绘，重绘不一定发生回流**

document fragmen
