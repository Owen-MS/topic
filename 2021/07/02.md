# 尾调用
## 定义
尾调用是函数编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。
## 尾调用优化
函数在调用的时候会在调用栈（call stack）中存有记录，每一条记录叫做一个调用帧（callframe），每调用一个函数，就向栈中push一条记录，函数执行后依次向外弹出，直到清空调用栈。
```
function foo () { console.log(111); }
function bar () { foo(); }
function baz () { bar(); }

baz();
```
![](https://user-gold-cdn.xitu.io/2018/4/11/162b410edd7877e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
造成这种结果是因为每个函数在调用另外一个函数的时候，并没有return该调用，
所以JS引擎会认为你还没有执行完，会保留你的调用帧。

修改上面例子
```
function foo () { console.log(111); }
function bar () { return foo(); }
function baz () { return bar(); }

baz();
```
这里要注意：**尾调用优化只在严格模式下有效**
在非严格模式下，大多数引擎会包含下面两个属性，以便开发者检查调用栈：

- func.arguments: 表示对 func最近一次调用所包含的参数
- func.caller: 引用对 func最近一次调用的那个函数

在尾调用优化中，这些属性不再有用，因为相关的信息可能以及被移除了。
因此，严格模式(strict mode)禁止这些属性，并且尾调用优化只在严格模式下有效。
如果尾调用优化生效，流程图就会变成这样：
![](https://user-gold-cdn.xitu.io/2018/4/11/162b410edd6f2c82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
我们可以很清楚的看到，尾调用由于是函数的最后一步操作，
所以不需要保留外层函数的调用记录，
只要直接用内层函数的调用记录取代外层函数的调用记录就可以了，
**调用栈中始终只保持了一条调用帧。**
这就叫做**尾调用优化**，如果所有的函数都是尾调用的话，
那么在调用栈中的调用帧始终只有一条，这样会节省很大一部分的内存，这也是尾调用优化的意义。
# 尾递归
## 递归的缺点：
递归解题相对常用的算法如普通循环等，运行效率较低。
因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。 
在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，因此递归次数过多容易造成栈溢出。
## 尾递归方案
如果一个函数返回自身递归调用的结果，
那么调用过程会被替换为一个循环，
它可以显著提高速度。 尾递归是一种在函数的最后执行递归调用语句的特殊形式的递归。


