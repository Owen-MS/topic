# 红宝书系列 第六章 集合引用类型
## 6.1 Object
在使用对象字面量表示法定义对象时，并不会实际调用object构造函数。

点语法和适用中括号存取属性：
1. 功能上没有区别
2. 中括号优势可以通过变量访问属性
## 6.2 Array
数组是一组有序的数据，不同于其他语言的是，数组中每个槽位可以存储任何类型的数据。
### 6.2.1 创建数组
与对象一样，在适用数组字面量表示法创建数组不会调用Array构造函数

Array构造函数在ES6新增了创建数组的静态方法：`from()` 和 `of()`。

`from()` 用于将类数组转换为数组实例。
第一个参数是一个类数组对象，即任何可迭代的结构，或者一个有length属性和可索引元素的结构。
第二个参数可选的映射函数参数。
第三个可选参数，用于指定映射函数中this的值。但这个重写的this在箭头函数中不适用。
```
Array.from([1,2,3], x => x * 2)
Array.from([1,2,3], function(x) { return x * this.exponent }, { exponent : 2 })
```
`of()` 用于将一组参数转换为数组实例。
```
Array.of(1,2,3,4) // [1,2,3,4]
Array.of(undefined) // [undefined]
```
### 6.2.2 数组空位
`[,,,,]`ES6新增的方法普遍会将这些空位当成存在的元素，只不过值为undefined；

ES6之前的方法则会忽略这些空位，但具体的行为也会因方法而异
1. map() 会跳过空位置
2. join() 视空位置为空字符串 // [1,,,,5].join('-'') "1----5"
### 6.2.3 数组索引
数组的length属性独特之处在于，它不是只读的。通过修改length属性，可以删除，添加元素。
数组最多包含4294967285个元素。超过报错。 99length题目
### 6.2.4 检测数组
默认情况下instanceof操作符足矣，因而只有一个全局作用域。
如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因为就会有两个不同版本的Array构造函数。如果要把数组从一个
框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。
为了解决这个问题，ECMAScript提供了Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不管它是在
哪个全局执行上下文。
### 6，2，5 迭代器方法
在ES6中，Array的原型上暴露了3个用于检索数组内容的方法：
- keys() 返回数组索引的迭代器
- values() 返回数组元素的迭代器
- entries() 返回索引/值对的迭代器。

### 6.2.6 复制和填充方法
ES6新增了两个方法：批量复制方法- copyWithin(), 以及填充数组方法fill().
这两个函数都需要指定数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。
```
// 用7去填充，索引大于等于1且小于3的元素, 如果为负数，即为加上当前数组长度，
// 超出数组边界、零长度，及方向相反的索引范围，忽略
[1,1,2,2,3,4].fill(7, 1, 3) // [1,7,7,2,3,4]

// 复制，0 ，3的数组，插入从4开始的位置
[1,2,3,4,5,6,7,8].copyWithin(4, 0 , 3) // [1, 2, 3, 4, 1, 2, 3, 8]
```
### 6.2.7 转换方法
所有对象都有toLocaleString(), toString(), valueof()

valueOf()返回的还是数组本身。

toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其toString();

如果数组中某一项是null或者undefined，则在join、toLocaleString、toString、valueOf返回的结果中会以空字符串表示。
```
[1,2,3,{s:1, toString: () => 98}].toString()
```

### 6.2.8 栈方法
利用push、pop 后进先出 LIFO

### 6.2.9 队列方法
利用push、unshift 先进先出 FIFO

### 6.2.10 排序方法
reverse、sort都返回调用它们的数组的引用

### 6.2.11 操作方法
concat、slice、splice、返回数组

### 6.2.12 搜索和位置方法
ECMAScript提供两类搜索数组的方法：按照严格相等搜索和按断言函数搜索。
1. 严格相等 `indexOf()、lastIndexOf()、ES7 includes()`

这些方法都接受两个参数，要查找的元素和一个可选的起始搜索位置。
2. 断言函数
`find()、findIndex()`接受三个参数，元素、索引、和数组本身
```
[1,2,3].find((element, index, array) => element)
```

### 6.2.13 迭代方法
- every
- some
- map
- filter
- forEach
每个方法接受两个参数，以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中this的值）。


传给每个方法的函数接受三个参数，数组元素、索引、数组本身

### 6.2.14 归并方法
ECMScript提供两个归并方法：reduce、reduceRight。一个从左往右一个从右往左
这两个方法都接受两个参数，对每一项都会允许的归并函数，以及可选的以之为归并起点的初始值。
归并函数接受四个参数：上一个归并值、当前项、索引、数组本身。

## 6.3 定型数组
##  6.4 Map
### 6.4.1 基本API
```
const m = new Map([
    ['key1', 'val1'],
    ['key2', 'val2'],
])
m.set('keys', 'val3') // 返回映射实例m

m.get('key3')
m.has('key3') // 初始化 m.has(undefined) // true
```
### 6.4.2 顺序与迭代
与object类型的一个主要差异就是，Map实例会维护键值对的插入顺序，因此可以根据顺序执行迭代操作。
```
m.entries ==== m[symbol.iterator] // true
m.forEach((val, key) => { } )
```
### 6.4.3 选择object还是Map
选择哪个都影响不大
**1. 内存占用**
工程级实现在不同浏览器间存在明显差异，但是存世单个键/值对所占用的内存数量都会随健的数量线性增加。
给定固定大小的内存，**Map大约可以object多存储50%的键值对。**
**2. 插入性能**
消耗大致相当，不过插入**Map在所有浏览器中一般会稍微快一点**。
**3. 查找速度**
object当成数组适用情况下，浏览器引擎可以进行优化，在内存中适用更高效的布局。大量查找操作，**object可能更好一点**。
**4. 删除性能**
object的删除一致饱受诟病，大量删除操作，**毫无疑问选择map**，map的delete操作比插入和查找更快。

## 6.5 weakMap
weak(弱): 描述的是Javascript垃圾回收程序对待'弱映射'中健的方式。
